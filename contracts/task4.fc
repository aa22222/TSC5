#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

(int) pack(int x, int s, int l, int i, int j) inline {
    return 1000000000000 * x + 1000000000 * s + 1000000 * l + 1000 * i + j;
}
(int, int, int, int, int) unpack(int x) inline {
    return (x / 1000000000000, x / 1000000000 % 1000, x / 1000000 % 1000, x / 1000 % 1000, x % 1000);
}

forall X -> (tuple) set(tuple t, X x, int i) asm "SETINDEXVAR";
forall X -> (tuple, ()) set2(tuple t, int i, int j, X x) inline {
    return (t.set(t.at(i).set(x, j), i), ());
}
(tuple, (tuple)) tpop(tuple t) asm "TPOP";
int tlen(tuple t) asm "TLEN";

const int MAXINT = 9223372036854776000;
const int X = 88;
const int S = 83;
const int E = 69;
const int Q = 63;
const int val! = 33;

(cell, (int)) pop(cell pq) inline {
    (int x, _, _) = pq~udict::delete_get_min(64);
    return (pq, (x));
}

(cell, ()) push(cell pq, int x) inline {
    return (pq.udict_set(64, x, begin_cell().end_cell().begin_parse()) , ());
}

;; (i, j, brokenX, super, length)
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    cell pq = new_dict();
    tuple notvis = empty_tuple();
    tuple paths = empty_tuple();
    int si = 0; int sj = 0;
    int ei = 0; int ej = 0;
    
    int i = 0; int j = 0;
    repeat(n){
        tuple cur = maze.at(i);
        tuple vis1 = empty_tuple();
        tuple path1 = empty_tuple();
        repeat(m){
            vis1~tpush(-1);
            path1~tpush(null());
            var c = cur.at(j);
            if(c == S){ si = i; sj = j; }
            if(c == E){ ei = i; ej = j; }

            j += 1;
        }
        notvis~tpush(vis1);
        paths~tpush(path1);

        i += 1; j = 0;
    }

    ;; Djikstras on (#X, #?, len)
    int s = pack(0, 0, 0, si, sj);
    notvis~set2(si, sj, 0); 
    pq~push(s);
    
    while(~ pq.dict_empty?()){
        var x = pq~pop();
        (int bX, int sup, int len, int i, int j) = unpack(x);

        tuple path = paths.at(i).at(j);
        
        if((i == ei) & (j == ej)){
            while (~ path.cdr().null?()) {
                (var x, path) = uncons(path);
                int ii = x / m; int jj = x % m;
                maze~set2(ii, jj, val!);
            }
            return (bX, sup, len, maze);
        }

        ;; Move to possible squares
        int di = 0; int dj = 0;
        repeat(9){
            int i' = i + di - 1;
            int j' = j + dj - 1;
            if((i' >= 0) & (i' < n) & (j' >= 0) & (j' < m)){
                if(notvis.at(i').at(j')){
                    int bX' = bX - (maze.at(i').at(j') == X);
                    int sup' = sup - (maze.at(i').at(j') == Q);
                    int s = pack(bX', sup', len + 1, i', j');

                    pq~push(s);
                    paths~set2(i', j', cons(i * m + j, path));
                    notvis~set2(i', j', 0); 
                }
            }
            dj += 1; di += dj / 3; dj %= 3;
        }
    }
    return (-1, 0, 0, null());
}
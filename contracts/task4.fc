#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}
forall X -> (tuple, ()) set(tuple t, X x, int k) asm "SETINDEXVAR";
const int MAXINT = 1000000000;
const int X = 88;
const int S = 83;
const int E = 69;
const int Q = 63;
const int val! = 33;

;; (i, j, brokenX, super, length)
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;; Get Start and End
    
    ;; (X, ?) = 1000 * X + ?
    tuple dp = empty_tuple();
    int ei = 0; int ej = 0;
    int i = 0; int j = 0;
    tuple dpd = empty_tuple();
    repeat(n){
        tuple dpi = empty_tuple();
        tuple cur = maze.at(i);
        repeat(m){
            var c = cur.at(j);
            if(c == S){
                dpi~tpush(0);
            }
            else {
                dpi~tpush(MAXINT);
            }

            if(c == E){
                ei = i;
                ej = j;
            }
            j += 1;
        }
        dpd~tpush(dpi);
        i += 1;
        j = 0;
    }
    dp~tpush(dpd);

    int d = 0; int i = 0; int j = 0;
    repeat(n * m){
        tuple dpd = empty_tuple();
        repeat(n){
            tuple dpi = empty_tuple();
            repeat(m){
                int di = -1; int dj = -1;
                int mn = MAXINT;
                repeat(3){
                    repeat(3){
                        int i' = i + di;
                        int j' = j + dj;

                        if((i' >= 0) & (i' < n) & (j' >= 0) & (j' < m)){
                            mn = min(mn, dp.at(d).at(i').at(j'));
                        }
                        dj += 1;
                    }
                    dj = -1;
                    di += 1;
                }
                if(maze.at(i).at(j) == X) {
                    mn += 1000;
                }
                if(maze.at(i).at(j) == Q) {
                    mn += 1;
                }

                dpi~tpush(mn);
                j += 1;
            }

            dpd~tpush(dpi);
            i += 1;
            j = 0;
        }

        dp~tpush(dpd);
        d += 1;
        i = 0; j = 0;
    }
    
    int d = 0;
    int mn = MAXINT;
    int mnd = -1;
    repeat(n * m){
        int g = dp.at(d).at(ei).at(ej);
        if(g < mn){
            mnd = d;
            mn = g;
        }
        d += 1;
    }


    int i = ei; int j = ej;
    int curx = mn;
    int d = mnd - 1;
    repeat(mnd - 1){
        int di = -1; int dj = -1;
        int ni = 0; int nj = 0;

        repeat(3){
            repeat(3){
                int i' = i + di;
                int j' = j + dj;

                if((i' >= 0) & (i' < n) & (j' >= 0) & (j' < m)){
                    if(dp.at(d).at(i').at(j') <= curx){
                        ni = i';
                        nj = j';
                    }
                }
                dj += 1;
            }
            dj = -1;
            di += 1;
        }

        curx = dp.at(d).at(ni).at(nj);
        i = ni;
        j = nj; 
        tuple temp = maze.at(i);
        temp~set(val!, j);
        maze~set(temp, i);
        ;; ~dump(ni);
        ;; ~dump(nj);
        ;; ~dump(maze);
        d -= 1;
    }
    
    return (mn / 1000, mn % 1000, mnd, maze);
}
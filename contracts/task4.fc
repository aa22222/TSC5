#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

forall X -> (tuple, ()) set(tuple t, X x, int i) asm "SETINDEXVAR";
(tuple, (tuple)) tpop(tuple t) asm "TPOP";
int tlen(tuple t) asm "TLEN";

const keySize = 33;
const int X = 88;
const int S = 83;
const int E = 69;
const int Q = 63;
const int val! = 33;
const slice blank = ""s;

;; (i, j, brokenX, super, length)
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    cell pq = new_dict();
    tuple notvis = empty_tuple();
    tuple paths = empty_tuple();
    int si = 0; int sj = 0;
    int ei = 0; int ej = 0;
    
    int i = 0; int j = 0;
    repeat(n){
        tuple cur = maze.at(i);
        tuple vis1 = empty_tuple();
        tuple path1 = empty_tuple();
        repeat(m){
            vis1~tpush(-1);
            path1~tpush(null());
            var c = cur.at(j);
            if(c == S){ si = i; sj = j; }
            if(c == E){ ei = i; ej = j; }

            j += 1;
        }
        notvis~tpush(vis1);
        paths~tpush(path1);

        i += 1; j = 0;
    }

    ;; Djikstras on (#X, #?, len)
    int s = 32 * si + sj;  
    notvis~set(notvis.at(si).set(0, sj), si);
    pq~udict_set(keySize, s, blank);
    
    while(~ pq.dict_empty?()){
        (int x, _, _) = pq~udict::delete_get_min(keySize);

        int j = x~divmod(32);
        int i = x~divmod(32);
        int len = x~divmod(500);
        int sup = x~divmod(500);
        int bX = x;

        tuple path = paths.at(i).at(j);
        
        if((i == ei) & (j == ej)){
            while (~ path.cdr().null?()) {
                (var x, path) = uncons(path);
                (int ii, int jj) = divmod(x, m);
                maze~set(maze.at(ii).set(val!, jj), ii);
            }
            return (bX, sup, len, maze);
        }

        ;; Move to possible squares
        int di = 0; int dj = 0;
        repeat(9){
            int i' = i + di - 1;
            int j' = j + dj - 1;
            dj += 1; di += dj / 3; dj %= 3;
            if((i' >= 0) & (i' < n) & (j' >= 0) & (j' < m)){
                if(notvis.at(i').at(j')){
                    int bX' = bX - (maze.at(i').at(j') == X);
                    int sup' = sup - (maze.at(i').at(j') == Q);

                    int s = bX';
                    s = s * 500 + sup';
                    s = s * 500 + len + 1;
                    s = s * 32 + i';
                    s = s * 32 + j';

                    pq~udict_set(keySize, s, blank);
                    paths~set(paths.at(i').set(cons(i * m + j, path), j'), i');
                    notvis~set(notvis.at(i').set(0, j'), i');
                }
            }
        }
    }
    return (-1, 0, 0, null());
}
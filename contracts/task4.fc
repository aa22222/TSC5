#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

(int) pack(int x, int s, int l, int i, int j) inline {
    return 1000000000000 * x + 1000000000 * s + 1000000 * l + 1000 * i + j;
}
(int, int, int, int, int) unpack(int x) inline {
    return (x / 1000000000000, x / 1000000000 % 1000, x / 1000000 % 1000, x / 1000 % 1000, x % 1000);
}

const int MAXINT = 99999999999999999999999999999999999;
const int X = 88;
const int S = 83;
const int E = 69;
const int Q = 63;
const int val! = 33;

(tuple, (tuple)) pop(tuple l){
    tuple re = double(MAXINT, null())
    tuple og = l;

    ;; Find best state, (least tuple)
    while (~ l.null?()) {
        (var x, l) = uncons(l);
        if(re.first() < x.first()){
            re = x;
        }
    }

    l = og;

    ;; Generate new list with best state removed
    tuple new = null();
    while (~ l.null?()) {
        (var x, l) = uncons(l);
        if(x.first() != re.first()){
            new = cons(x, new);
        }
    }

    return (new, (re));
}

;; (i, j, brokenX, super, length)
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    var pq = null();
    tuple vis = empty_tuple();

    ;; Get Start and End
    int si = 0; int sj = 0;
    int ei = 0; int ej = 0;
    
    int i = 0; int j = 0;
    repeat(n){
        tuple cur = maze.at(i);
        tuple vis1 = empty_tuple();
        repeat(m){
            vis1~tpush(0);
            var c = cur.at(j);
            if(c == S){
                si = i;
                sj = j;
            }
            if(c == E){
                ei = i;
                ej = j;
            }
            j += 1;
        }
        vis~tpush(vis1);
        i += 1;
        j = 0;
    }

    ;; Djikstras on (#X, #?, len)
    tuple s = double(pack(0, 0, 0, si, sj), null());
    pq = cons(s, pq);
    while(~ pq.null?()){
        var x = pq~pop();
        
        (int bX, int sup, int len, int i, int j) = unpack(x.first());
        if(~ vis.at(i).at(j)){ ;; check if (i, j) is visited
            vis.set(i, j, 1); ;; mark as visited
            tuple path = x.second();
            
            ;; If End is reached, construct mazePath.
            if((i == ei) & (j == ej)){
                tuple mazePath = empty_tuple();
                int ii = 0;
                int jj = 0;
                repeat(n){
                    tuple row = empty_tuple();
                    repeat(m){
                        ;; Start square
                        if((ii == si) & (jj == sj)) {
                            row~tpush(maze.at(ii).at(jj));
                        }

                        ;; part of path
                        elseif(in(path, ii * m + jj)) {
                            row~tpush(val!);
                        }

                        ;; other
                        else {
                            row~tpush(maze.at(ii).at(jj));
                        }
                        jj += 1;
                    }
                    ii += 1;
                    jj = 0;
                    mazePath~tpush(row);
                }
                return (bX, sup, len, mazePath);
            }

            ;; Move to possible squares
            int di = -1; int dj = -1;
            repeat(3){
                repeat(3){
                    int i' = i + di;
                    int j' = j + dj;
                   
                    if((i' >= 0) & (i' < n) & (j' >= 0) & (j' < m)){
                        int bX' = bX; int sup' = sup; int len' = len + 1;
                        
                        ;; isX?
                        if(maze.at(i').at(j') == X){
                            bX' += 1;
                        } 

                        ;; isSup?
                        if(maze.at(i').at(j') == Q){
                            sup' += 1;
                        } 

                        tuple s = state(i', j', bX', sup', len', cons(i * m + j, path));
                        pq = cons(s, pq);
                    }
                    dj += 1;
                }
                dj = -1;
                di += 1;
            }
        }
    }
    return (-1, 0, 0, null());
}
#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

forall X -> (tuple, ()) ~set(tuple t, X x, int i) asm "SETINDEXVAR";
forall X -> tuple set(tuple t, X x, int i) asm "SETINDEXVAR";

const keySize = 33;
const int X = 88;
const int S = 83;
const int E = 69;
const int Q = 63;
const int val! = 33;
const slice blank = ""s;

;; (i, j, brokenX, super, length)
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    cell pq = new_dict();
    tuple notvis = empty_tuple();
    int si = 0; int sj = 0;
    int ei = 0; int ej = 0;
    
    int i = 0; int j = 0;
    repeat(n){
        tuple cur = maze.at(i);
        tuple vis1 = empty_tuple();
        repeat(m){
            vis1~tpush(-1);
            var c = cur.at(j);
            if(c == S){ si = i; sj = j; }
            if(c == E){ ei = i; ej = j; }

            j += 1;
        }
        notvis~tpush(vis1);

        i += 1; j = 0;
    }
    tuple paths = notvis;

    ;; Djikstras on (#X, #?, len)
    int s = 32 * si + sj;  
    notvis~set(notvis.at(si).set(0, sj), si);
    pq~udict_set(keySize, s, blank);
    
    repeat(1000){
        (int x, _, _) = pq~udict::delete_get_min(keySize);

        int j = x~divmod(32);
        int i = x~divmod(32);
        int len = x~divmod(512);
        int sup = x~divmod(512);
        int bX = x;

        if((i == ei) & (j == ej)){
            repeat(len - 1){
                (i, j) = divmod(paths.at(i).at(j), 1024);
                maze~set(maze.at(i).set(val!, j), i);
            }
            return (bX, sup, len, maze);
        }

        ;; Move to possible squares
        int k = 0;
        repeat(9){
            int i' = i + k / 3 - 1;
            int j' = j + k % 3 - 1;
            k += 1;
            if((i' >= 0) & (i' < n) & (j' >= 0) & (j' < m)){
                if(notvis.at(i').at(j')){
                    int bX' = bX - (maze.at(i').at(j') == X);
                    int sup' = sup - (maze.at(i').at(j') == Q);

                    int s = bX';
                    s = s * 512 + sup';
                    s = s * 512 + len + 1;
                    s = s * 32 + i';
                    s = s * 32 + j';

                    pq~udict_set(keySize, s, blank);
                    paths~set(paths.at(i').set((i << 10) + j, j'), i'); ;; paths[i'][j'] = i << 10 + j
                    notvis~set(notvis.at(i').set(0, j'), i');
                }
            }
        }
    }
    return (-1, 0, 0, null());
}
